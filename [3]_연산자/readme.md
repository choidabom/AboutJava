# Chapter 3. 연산자(Operator)

## 1. 연산자
### 1. 연산자(Operator)란?

- 연산자: 연산을 수행하는 기호(+, -, *, /)
- 피연산자: 연산의 대상
- **연산자는 피연산자로 연산을 수행하고 나면 항상 결과값을 반환한다.**

- 식: 연산자와 피연산자를 조합하여 계산하고자 하는 바를 표현한 것
- 식을 평가: 식을 계산하여 결과를 얻는 것

### 2. 연산자의 종류

- 산술 연산자: `+`, `-`, `*`, `/`, `%`, `<<`, `>>`
    - 사칙 연산(`+`, `-`, `*`, `/`)과 나머지 연산(`%`)
- 비교 연산자: `>`, `<`, `≥`, `≤`, `==`, `≠`
    - 크고 작음과 같고 다름을 비교
- 논리 연산자: `&&`, `||`, `!`, `&`, `|`, `^`, `~`
    - '그리고(AND)'와 '또는(OR)'으로 조건을 연결
    - &&(AND), ||(OR), !(NOT)
- 대입 연산자: `=`
    - 우변의 값을 좌변에 저장
- 기타: `(type)`, `?:`, `instanceof`
    - 형변환 연산자, 삼항 연산자, instanceof 연산자

### 3. 연산자의 우선순위와 결합규칙

#### 연산자의 우선순위
:"하나의 식(expression)에 연산자가 둘 이상 있을 때, 어떤 연산을 먼저 수행할지를 자동 결정하는 것"

`상식적으로 생각하라. 우리는 이미 다 알고 있다.`

- 단항 연산자가 이항 연산자보다 우선순위가 높다.
    - ex> `-x + 3`
- `*`, `/`이 `+`, `-`보다 우선순위가 높다.
- 비교 연산자 보다 산술 연산자가 먼저 수행된다.
- 논리 연산자 보다 비교 연산자가 먼저 수행된다.
- 대입 연산자는 연산자 중에서 제일 우선순위가 낮다.
- 산술 연산자 중, `x << 2 + 1` 쉬프트 연산자는 덧셈 연산자보다 우선순위가 낮다.
- 비트 연산자는 비교 연산자 보다 우선순위가 낮으므로 비교연산 후에 비트 연산이 수행된다.
    - ex> `data & 0xFF == 0` → `data & (0xFF == 0)`
- 논리 연산자 중, AND(`&`, `&&`)가 OR(`|`, `||`)보다 우선순위가 높다.

#### 연산자의 결합규칙
: "우선순위가 같은 연산자가 있을 때, 어떤 것을 먼저?"

연산자의 우선순위

1. 산술 > 비교 > 논리 > 대입
2. 단항 > 이항 > 삼항
3. 단항 연산자와 대입 연산자를 제외한 **모든 연산의 진행방향은 왼쪽 => 오른쪽**

- 연산자의 우선순위와 결합규칙 표

 ![image](https://user-images.githubusercontent.com/48302257/178870649-7d6425be-f002-42b0-887b-997ce1dc0b72.png)

### 4. 산술 변환(usual arithmetic conversion)

- (일반) 산술 변환: 연산 전에 피연산자 타입의 일치를 위해 자동 형변환되는 것
- 이항 연산에서만 아니라 단항 연산에서도 일어난다.

1. 두 피연산자의 타입을 같게 일치시킨다.(보다 큰 타입으로 일치)
    - ex> `float + int` → `float + float`
2. 피연산자의 타입이 int 보다 작은 타입이면 int 로 변환된다.
    - ex1> `byte + short` → `int + int`
    - ex2> `char + short` → `int + int`


## 2. 단항 연산자

### 1. 증감 연산자 ++ --

- 증가연산자(++): 피연산자의 값을 1 증가시킨다.
- 감소연산자(--): 피연산자의 값을 1 감소시킨다.
- 
![image](https://user-images.githubusercontent.com/48302257/178882249-ba2fbcbe-89c7-4b54-a510-1c512d9dd7a3.png)

=> **전위형일 때와 후위형일 때를 잘 체크해봐야한다!** 

But, 전위형, 후위형이 독립적으로 쓰였을 때는 차이가 없다.

<p align="center"><img src="https://user-images.githubusercontent.com/48302257/178883691-541c37f9-e834-4dc5-846b-f4edb3f45ba0.png">

- 식에 2번 이상 포함된 변수에 증감연산자를 사용하는 것은 피해야 한다.
 
### 2. 부호 연산자 + -

- 부호 연산자 `-`는 피연산자의 부호를 반대로 변경한 결과를 반환한다.
- `+`는 아무런 일도 하지 않는다. (실제 사용 x)
- boolean 형과 char 형을 제외한 기본형에만 사용할 수 있다.


## 3. 산술 연산자

### 1. 사칙 연산자 + - * /

- `*`, `/`, `%` 연산자가 `+`, `-` 연산자보다 우선순위가 높다.

**형변환**이란, 변수 또는 상수의 타입을 다른 타입으로 변환하는 것

**(타입)피연산자**
```java
  double d = 85.4;
  int score = (int) d;
  => int score = 85;
```
<p align="center"><img src="https://user-images.githubusercontent.com/48302257/178887219-e20ba513-0b9e-4078-bdda-0175d01f23b9.png">

* 유니코드를 참조해야한다.
* float에서 int로 바뀔 때 반올림 되지 않는다.

- 자동 형변환 
  ```java
    float f = 1234; //int 타입의 값을 float 타입의 변수에 저장
    float f = (float) 1234; 
  => 컴파일러가 자동으로 형변환을 해준다.
    
    int i = 3.14f; //에러
  => 큰 값을 작은 쪽에 넣으면 값 손실이 발생하기 때문에 컴파일러가 자동으로 형변환 안 해준다. 
    int i = (int)3.14f;
  => so, 직접 형변환 해야함.
  ```
- 더 좁은 범위로 형변환을 하면 값의 손실이 발생할 수 있다.

    ![image](https://user-images.githubusercontent.com/48302257/178888507-f546ca46-0f08-4ae0-a4bd-38e19fb6bf52.png)

    - int 형을 byte 형으로 변환하는경우 하위 8자리(1byte)만 보존하기에 그외에 값이 손실된다.
- 연산 전에 큰 자료형을 사용하여 오버플로우를 막아야 한다.

    ```java
    public static void main(String[] args) {
        int a = 1_000_000;
        int b = 2_000_000;

        long value = a * b;

        System.out.println(value);
    }
    ```

    - 실행 결과

        ```java
        -1454759936
  => overflow
        ```
- 올바른 결과를 얻으려면 피연산자 중 하나를 long 으로 만들어야 한다.
  
  ![image](https://user-images.githubusercontent.com/48302257/178890105-dbd1cd51-f801-4baa-9c68-b52eaa130f99.png)

  
- 같은 의미의 식이라도 연산의 순서에 따라 다른 결과를 얻을 수 있다.

    ```java
    public static void main(String[] args) {
        int a = 1000000;

        int result1 = a * a / a;
        int result2 = a / a * a;

        System.out.printf("%d * %d / %d = %d %n", a, a, a, result1);
        System.out.printf("%d / %d * %d = %d %n", a, a, a, result2);
    }
    ```

    - 실행 결과

        ```java
        1000000 * 1000000 / 1000000 = -727
        1000000 / 1000000 * 1000000 = 1000000
        ```

    - 먼저 곱하는 경우 int 의 범위를 넘어서기 때문


- 리터럴간의 연산

    ```java
    char value = 'a' + 1;
    ```

    → 위 코드는 에러가 발생하지 않는다.  char형과 int형간의 연산이면 더 큰 범위인 int형으로 형변환되기에 에러가 발생해야 하지 않을까?

    이는 위 코드의 연산이 **리터럴간의 연산이기 때문!**

    상수 또는 리터럴 간의 연산은 실행 과정동안에 변하는 값이 아니라 컴파일 시에 계산해서 그 결과로 대체하는 것(코드를 보다 효율적으로 만든다)이기 때문에 컴파일 후에는 이미 `char value = 'b';` 가 되어있기 때문에 덧셈 연산이 수행되지 않는다.

    하지만, 수식에 변수를 통한 연산은 컴파일러가 미리 계산을 할 수 없기 때문에 명시적 형변환을 해줘야 에러가 발생하지 않는다.

    - ex> 또 다른 예, 반나절을 초(sec)로

        : `86400` == `60 * 60 * 12`

### 2. 나머지 연산자 **%**

- 오른쪽 피연산자로 나누고 남은 나머지를 반환
- 결국 나눗셈을 수행하기에 나눗셈과 같이 **나누는 수(우측 피연산자)로 0을 사용할 수 없다.**
- 정수만 허용(부호는 무시됨)

```java
int remainderValue = 10 % 3;
System.out.println(remainderValue);  // 1
```

- 그러나 나누는 수로 음수는 허용한다.

    ```java
    -10 % 8 = -2
    ```

    - 부호 무시하고 나머지 연산 후 왼쪽 피연산자의 부호를 붙여주면 된다.


## 4. 비교 연산자

### 1. 대소비교 연산자 `< > <= >=`

- 대소비교 연산자: 두 피연산자의 값의 크기를 비교하는 연산자
- `<=`, `>=`의 경우 반드시 앞에 부등호가 먼저 나오고 등호가 나와야한다.
  
### 2. 등가비교 연산자 `== !=`

- 등가비교 연산자: 두 피연자의 값이 같은지 또는 다른지 비교하는 연산자 (연산 수행 전에 자동 형변환)
- `0.1 == 0.1f : false`
    - 정수형과 달리 실수형은 근사값으로 저장되므로 오차가 발생할 수 있다.
  
### 문자열의 비교
=> **문자열 비교에는 == 대신 equals()를 사용해야 한다.**
```java
  1)
  String str1 = "abc";
  String str2 = "abc";
  
  System.out.println(str1=str2); //true
  System.out.println(str1.equals(str2)); //true
  
  2) 1)으로 하는 경우가 대부분이지만 2)의 경우도 존재한다. (6장, 9장)
  String str1 = new String("abc");
  String str2 = new String("abc");
  
  System.out.println(str1=str2); //false
  System.out.println(str1.equals(str2)); //true
```
  
## 5. 논리 연산자

### 1. 논리연산자 **&& || !**

- 논리 연산자: 둘 이상의 조건을 AND 나 OR 로 연결하여 하나의 식으로 표현할 수 있게 해준다.
  
- **&&(AND결합)**: 피연산자 양쪽 모두 true이어야 true를 결과로 얻는다.
- **||(OR결합)**: 피연산자 중 어느 한 쪽이 true이면 true를 결과로 얻는다.
  
```java
  1) x는 10보다 크고 20보다 작다.
    x > 10 && x <20
           or
    10 < x && x < 20
                    
  2) i는 2의 배수 또는 3의 배수이다.
    i%2==0 || i%3==0
                    
  3) i는 2의 배수 또는 3의 배수지만 6의 배수는 아니다.
     (i%2==0 || i%3==0) && i%6!==0
     => &&가 ||보다 우선순위가 높기 때문에 괄호를 사용한다.
  
  4) 문자 ch는 숫자('0'~'9')이다.
     '0' <= ch && ch <= '9'
  
  5) 문자 ch는 대문자 또는 소문자이다.
    ('a'<= ch && ch <='z')||('A'<= ch && ch <='Z')
```
- **논리 부정 연산자 `!`**
    - true / false 를 반대로 바꾼다.
<p align="center"><img src="https://user-images.githubusercontent.com/48302257/178904223-90d6c484-c2fd-44a3-8a8a-694982af627b.png">


## 6. 그 외의 연산자

### 1. 조건연산자 ?

- 조건연산자: **3개의 피연산자를 필요로 하는 삼항 연산자**. 오른쪽에서 왼쪽으로 결합규칙이 적용된다.
- **조건식 ? 식1 : 식2**
- 식 1: true
  식 2: false
    ```java
  result = (x > y) ? x : y; // 괄호 생략 가능
  => x가 크면 result가 true
  => y가 크면 result가 false
  
  삼항연산자는 **if문을 간단히 쓸 수 있게 고안된 연산자**
  if (x > y)
    result = x;
  else
    result = y;
    ```

### 2. 대입 연산자 =

- 대입 연산자: 오른쪽 피연산자를 왼쪽 피연산자에 저장 후 저장된 값을 반환

- lvalue 와 rvalue
    - **lvalue**: 대입 연산자의 **왼쪽 피연산자**, 변수처럼 값을 변경할 수 있는 것이어야 한다. (저장공간)
    - **ravlue**: **오른쪽 피연산자**, 식이나 상수 등이 모두 가능하다.
  
<p align="center"><img src="https://user-images.githubusercontent.com/48302257/178905166-79fc681a-43f5-4b62-84a9-ec7d18730944.png">

- 복합 대입 연산자
  
<p align="center"><img src="https://user-images.githubusercontent.com/48302257/178905228-87b3f0c7-6b9d-4021-a598-ee15870a5734.png">

* 맨 마지막 젤 조심해야함.
  
  => i *= (10 + k); 
  
  => 괄호 안 치는 경우 결과값이 달라짐.
  
### 3. 반올림 Math.round()
  실수를 소수점 첫째자리에서 반올림한 정수를 반환
  long result = Math.round(4.52); //result에 5가 저장된다.
  <p align="center"><img src="https://user-images.githubusercontent.com/48302257/178897267-37bad166-a422-4bed-b725-955ae7b96cac.png">

  ```java
    결과 도출 과정)
    
    Math.round(pi * 1000) / 1000.0
    Math.round(3.141592 * 1000) / 1000.0
    Math.round(3141.592)  / 1000.0
    3142/1000.0
    3.142
  ```
 <p align="center"><img src="https://user-images.githubusercontent.com/48302257/178899231-98f5efbc-458b-4475-9ceb-3597f8c0965f.png">

  * 소수점 반올림이 아니라 소수점 잘라내고 싶을 때
 <p align="center"><img src="https://user-images.githubusercontent.com/48302257/178899521-55ae4862-8b0a-4051-8243-3e31623607f6.png">
